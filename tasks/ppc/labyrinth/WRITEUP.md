–ü–æ–¥–∫–ª—é—á–∞–µ–º—Å—è, –≤–∏–¥–∏–º:  
<img src="https://user-images.githubusercontent.com/24609869/203986796-8908e9b4-3e41-4215-97df-853e6482d5cf.png" width="500px"/>

–ß–∏—Ç–∞–µ–º, –ø–æ–Ω–∏–º–∞–µ–º —á—Ç–æ –Ω–∞–¥–æ –ø–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å `üòé` –∫ —Ñ–ª–∞–≥—É `‚õ≥Ô∏è` —Å –ø–æ–º–æ—â—å—é –∫–æ–º–º–∞–Ω–¥: 1(–≤–≤–µ—Ä—Ö), 2(–≤–Ω–∏–∑), 3(–≤–ø—Ä–∞–≤–æ), 4(–≤–ª–µ–≤–æ).  

–ó–∞–¥–∞—á–∞ –≤ —Ü–µ–ª–æ–º, –Ω–µ —Å–ª–æ–∂–Ω–∞—è, –≥–ª–∞–≤–Ω–æ–µ —Ä–∞–∑–æ–±—Ä–∞—Ç—å—Å—è —Å –ø–∞—Ä—Å–∏–Ω–≥–æ–º –∏ –∞–ª–≥–æ—Ä–∏—Ç–º–æ–º –ø–æ–∏—Å–∫–∞ –ø—É—Ç–∏.  
–ü–∞—Ä—Å–∏–Ω–≥ –Ω–µ —Å–ª–æ–∂–Ω—ã–π, —Å—á–∏—Ç—ã–≤–∞–µ–º —Å—Ç—Ä–æ–∫–∏ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ –∏ –∑–∞–º–µ–Ω—è–µ–º `üü¶` –Ω–∞ 1, –∞ `  `(2 –ø—Ä–æ–±–µ–ª–∞), –Ω–∞ 0. –ü–æ–ª—É—á–∞–µ–º –¥–≤—É–º–µ—Ä–Ω—ã–π –º–∞—Å—Å–∏–≤, –≥–¥–µ 1 = —Å—Ç–µ–Ω–∞, 0 = —Å–≤–æ–±–æ–¥–Ω–∞—è –∫–ª–µ—Ç–∫–∞.  
–ê–ª–≥–æ—Ä–∏—Ç–º–æ–≤ –ø–æ–∏—Å–∫–∞ –ø—É—Ç–∏ –º–Ω–æ–≥–æ: –ø—Ä–∞–≤–∏–ª–æ "–æ–¥–Ω–æ–π —Ä—É–∫–∏", –∞–ª–≥–æ—Ä–∏—Ç–º –î–µ–π–∫—Å—Ç—Ä—ã, –∞–ª–≥–æ—Ä–∏—Ç–º –≤–æ–ª–Ω–æ–≤–æ–π —Ç—Ä–∞—Å—Å–∏—Ä–æ–≤–∫–∏ –∏ –¥—Ä—É–≥–∏–µ. –°—Ä–∞–∑—É, –æ—Ç–±—Ä–∞—Å—ã–≤–∞–µ–º –ø—Ä–∞–≤–∏–ª–æ "–æ–¥–Ω–æ–π —Ä—É–∫–∏", —Ç–∞–∫-–∫–∞–∫ —ç—Ç–æ –ø–æ —Ñ–∞–∫—Ç—É –ø—Ä–æ—Å—Ç–æ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω—ã–π –ø—Ä–æ—Ö–æ–¥ –ø–æ –≤—Å–µ–º—É –ª–∞–±–∏—Ä–∏–Ω—Ç—É, –∞ —É –Ω–∞—Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –Ω–∞ 200 –∫–æ–º–∞–Ω–¥. –î–∞–ª—å—à–µ, –≤ –ø—Ä–∏–Ω—Ü–∏–ø–µ, –∞–ª–≥–æ—Ä–∏—Ç–º –º–æ–∂–Ω–æ –≤—ã–±—Ä–∞—Ç—å –ª—é–±–æ–π, –∫ —Ç–æ–º—É –∂–µ –Ω–∞–º –¥–∞–Ω–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è, —á—Ç–æ –ª–∞–±–∏—Ä–∏–Ω—Ç —É–¥–æ–≤–ª–µ—Ç–≤–æ—Ä—è–µ—Ç —É—Å–ª–æ–≤–∏—é "–∏–¥–µ–∞–ª—å–Ω–æ–≥–æ –ª–∞–±–∏—Ä–∏–Ω—Ç–∞", —Ç.–µ. –∏–∑ –∫–∞–∂–¥–æ–π —Ç–æ—á–∫–∏ –º–æ–∂–Ω–æ –ø–æ–ø–∞—Å—Ç—å –≤ –ª—é–±—É—é –¥—Ä—É–≥—É—é –∏ –≤—Å–µ–≥–æ –æ–¥–Ω–∏–º –ø—É—Ç–µ–º.
–í —Ä–µ—à–µ–Ω–∏–∏ —è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª –∞–ª–≥–æ—Ä–∏—Ç–º –≤–æ–ª–Ω–æ–≤–æ–π —Ç—Ä–∞—Å—Å–∏—Ä–æ–≤–∫–∏, –µ–≥–æ —Ä–∞–∑–±–æ—Ä –º–æ–∂–µ—Ç–µ –ø—Ä–æ—á–µ—Å—Ç—å [–∑–¥–µ—Å—å](http://www.100byte.ru/100btwrks/wv/wv.html) –∏ [–∑–¥–µ—Å—å —Å –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–º –ø—Ä–∏–º–µ—Ä–æ–º](https://suvitruf.ru/2012/05/13/1176/volnovoj-algoritm-algoritm-li/).

[–°–∫—Ä–∏–ø—Ç](./solve.py):
```python
# -*- coding: utf-8 -*-
from pwn import *

PATH = -5
START = -4
FINISH = -3
WALL = -2
CELL = -1

UP = 1
DOWN = 2
RIGHT = 3
LEFT = 4

class Point:
	def __init__(self, x, y):
		self.x, self.y = x, y


# –ü–∞—Ä—Å–∏–º –ª–∞–±–∏—Ä–∏–Ω—Ç –≤ –¥–≤—É–º–µ—Ä–Ω—ã–π –º–∞—Å—Å–∏–≤, —ç–º–æ–¥–∑–∏ –∑–∞–º–µ–Ω—è–µ–º –Ω–∞ –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã: CELL, WALL, FINISH, START
def parse_maze(r):
	maze = []
	for i in range(31):
		line = r.recvline().decode("utf-8").replace("  ", " ").replace("\n", "")

		binary = []
		for c in line:
			if c == " ":
				binary.append(CELL)
			elif c == "üü¶":
				binary.append(WALL)
			elif c == "‚õ≥":
				binary.append(FINISH)
			elif c == "üòé":
				binary.append(START)
		maze.append(binary)

	return maze

# –†–µ–∞–ª–∏–∑—É–µ—Ç —à–∞–≥ —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω–µ–Ω–∏—è –≤–æ–ª–Ω—ã –∏–∑ —Ç–æ—á–∫–∏ src, —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—è —Å–æ—Å–µ–¥—è–º –∑–Ω–∞—á–µ–Ω–∏–µ val
def init_wave(trace, src, val):
	changed = False
	if src.x < len(trace[0]) - 1:
		if trace[src.y][src.x + 1] == CELL:
			trace[src.y][src.x + 1] = val
			changed = True

	if src.x > 0:
		if trace[src.y][src.x - 1] == CELL:
			trace[src.y][src.x - 1] = val
			changed = True

	if src.y > 0:
		if trace[src.y - 1][src.x] == CELL:
			trace[src.y - 1][src.x] = val
			changed = True

	if src.y < len(trace) - 1:
		if trace[src.y + 1][src.x] == CELL:
			trace[src.y + 1][src.x] = val
			changed = True

	return changed

# –†–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω—è–µ—Ç –≤–æ–ª–Ω—É –Ω–∞ –æ–¥–∏–Ω —à–∞–≥ –¥–ª—è –∫–∞–∂–¥–æ–π —Ç–æ—á–∫–∏ —Å–æ –∑–Ω–∞—á–µ–Ω–∏–µ–º —Ä–∞–≤–Ω—ã–º step
def spread_wave(trace, step):
	changed = False
	for y in range(len(trace)):
		for x in range(len(trace[y])):
			if trace[y][x] == step:
				if init_wave(trace, Point(x, y), step+1):
					changed = True

	return changed

# –í—ã–±–∏—Ä–∞–µ—Ç —Å–æ—Å–µ–¥–∞ –∫–ª–µ—Ç–∫–∏ —Å –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–º –∑–Ω–∞—á–µ–Ω–∏–µ–º.
# –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø–æ–∑–∏—Ü–∏—é —Å–æ—Å–µ–¥–∞ –∏ –¥–≤–∏–∂–µ–Ω–∏–µ —á—Ç–æ–±—ã –ø–µ—Ä–µ–π—Ç–∏ –∫ –Ω–µ–º—É.
# (–î–ª—è –æ—Å–∏ Y –¥–≤–∏–∂–µ–Ω–∏—è –∏–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞–Ω—ã, —Ç–∞–∫-–∫–∞–∫ –ø–æ—Ç–æ–º –∑–Ω–∞—á–µ–Ω–∏—è –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –¥–ª—è —Å–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—è –ø—É—Ç–∏ –æ—Ç src –∫ dst)
def get_min_neighbour(trace, cell):
	min_n = cell
	min_val = trace[cell.y][cell.x]
	move = None

	if cell.x > 0 and trace[cell.y][cell.x - 1] not in [CELL, WALL, PATH]:
		if trace[cell.y][cell.x - 1] < min_val:
			min_n = Point(cell.x - 1, cell.y)
			min_val = trace[min_n.y][min_n.x]
			move = RIGHT

	if cell.x < len(trace[0]) - 1 and trace[cell.y][cell.x + 1] not in [CELL, WALL, PATH]:
		if trace[cell.y][cell.x + 1] < min_val:
			min_n = Point(cell.x + 1, cell.y)
			min_val = trace[min_n.y][min_n.x]
			move = LEFT

	if cell.y > 0 and trace[cell.y - 1][cell.x] not in [CELL, WALL, PATH]:
		if trace[cell.y - 1][cell.x] < min_val:
			min_n = Point(cell.x, cell.y - 1)
			min_val = trace[min_n.y][min_n.x]
			move = DOWN

	if cell.y < len(trace) - 1 and trace[cell.y + 1][cell.x] not in [CELL, WALL, PATH]:
		if trace[cell.y + 1][cell.x] < min_val:
			min_n = Point(cell.x, cell.y + 1)
			min_val = trace[min_n.y][min_n.x]
			move = UP

	return min_n, move

# –ù–∞—Ö–æ–¥–∏—Ç –æ–±—Ä–∞—Ç–Ω—ã–π –ø—É—Ç—å –æ—Ç dst –≤ src. –í –∫–æ–º–∞–Ω–¥–∞—Ö UP, DOWN, LEFT, RIGHT
# –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ä–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –ø—É—Ç—å, —Ç.–µ. –ø—É—Ç—å –æ—Ç src –¥–æ dst.
def backtrace_path(trace, src, dst):
	moves = []
	c = 0
	while dst.x != src.x or dst.y != src.y:
		min_n, move = get_min_neighbour(trace, dst)
		moves.append(move)
		trace[dst.y][dst.x] = PATH
		dst = min_n

	return moves[::-1]

# –†–µ–∞–ª–∏–∑—É–µ—Ç –∞–ª–≥–æ—Ä–∏—Ç–º –≤–æ–ª–Ω–æ–≤–æ–π —Ç—Ä–∞—Å—Å–∏—Ä–æ–≤–∫–∏. 
# –ò–Ω–∏—Ü–∏–∏—Ä—É–µ—Ç –≤–æ–ª–Ω—É –∏–∑ —Ç–æ—á–∫–∏ src –∏ —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω—è–µ—Ç –¥–æ —Ç–µ—Ö –ø–æ—Ä –ø–æ–∫–∞ –Ω–µ –¥–æ—Å—Ç–∏–≥–Ω–µ—Ç dst,
# –ª–∏–±–æ –Ω–µ –ø–æ–∫—Ä–æ–µ—Ç –≤—Å–µ –¥–æ—Å–∏–≥–∞–µ–º—ã–µ –∫–ª–µ—Ç–∫–∏.
# –í –∫–æ–Ω—Ü–µ —Ñ–æ—Ä–º–∏—Ä—É
def trace_maze(maze):
	dst, src = None, None
	for y, line in enumerate(maze):
		for x, c in enumerate(line):
			if c == START:
				src = Point(x, y)
			
			if c == FINISH:
				dst = Point(x, y)

		if src and dst:
			break

	trace = [row[:] for row in maze]
	trace[dst.y][dst.x] = CELL

	init_wave(trace, src, 1)
	step = 1
	
	while spread_wave(trace, step):
		step += 1
		if trace[dst.y][dst.x] != CELL:
			break


	path = backtrace_path(trace, src, dst)
	return trace, path

# –í—ã–≤–æ–¥–∏—Ç –ª–∞–±–∏—Ä–∏–Ω—Ç —Å —Ç—Ä–∞—Å—Å–∏—Ä–æ–≤–∫–æ–π.
def print_traced_maze(maze, trace):
	for y, line in enumerate(maze):
		for x, c in enumerate(line):
			if c == WALL:
				print("üü¶", end="")
			elif c == CELL:
				if trace[y][x] != CELL:
					if trace[y][x] == PATH:
						print("üü©", end="")
					else:
						print("%02d" % trace[y][x], end="")
				else:
					print("  ", end="")
			elif c == START:
				print("üòé", end="")
			else:
				print("‚õ≥Ô∏è", end="")

		print()


r = remote("185.104.115.19", 9966)
# r = remote("localhost", 9966)
r.recvuntil("200 –∫–æ–º–∞–Ω–¥.\n".encode("utf-8"))

c = 1
try:
	while True:
		print("MAZE: ", c)
		r.recvuntil(b"]\n")
		maze = parse_maze(r)
		trace, path = trace_maze(maze)
		print_traced_maze(maze, trace)
		
		r.sendline(''.join(map(str, path)).encode("utf-8"))


		# –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –≤—ã–≤–æ–¥ –ø—Ä–æ–π–¥–µ–Ω–Ω–æ–≥–æ –ø—É—Ç–∏ —Å–µ—Ä–≤–µ—Ä–æ–º
		for i in range(31):
			r.recvline()

		c += 1
except:
	r.interactive()
finally:
	r.close()
```
–°–∫—Ä–∏–ø—Ç, –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ, –≤—ã–≤–æ–¥–∏—Ç —Ç—Ä–∞—Å—Å–∏—Ä–æ–≤–∫—É –ª–∞–±–∏—Ä–∏–Ω—Ç–∞ –¥–ª—è –Ω–∞–≥–ª—è–¥–Ω–æ—Å—Ç–∏.  
–ü–æ—Å–ª–µ –ø—Ä–æ—Ö–æ–∂–¥–µ–Ω–∏—è 250 –ª–∞–±–∏—Ä–∏–Ω—Ç–æ–≤, –ø–æ–ª—É—á–∞–µ–º —Ñ–ª–∞–≥:  
<img src="https://user-images.githubusercontent.com/24609869/203989564-727b3882-f71e-4d6d-aabb-efb1660acb0a.png" width="400px"/>

`flag: surctf_easy_m4ze_n0t_3asy_alg`
